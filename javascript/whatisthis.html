<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible"
          content="ie=edge">
    <title>Document</title>
</head>

<body>

    <script>
        // function identify() {
        //     return this.name.toUpperCase();
        // }

        // function speak() {
        //     var greeting = "hello, I'm " + identify.call(this)
        // }

        // var me = { name: "Kyle" }
        // var you = { name: "Reader" }
        // console.info(identify.call(me))
        // console.info(identify.call(you))
        // console.info(speak.call(you))
        // console.info(speak(you))
        // function foo(num) {
        //     console.log("foo" + num)

        //     foo.count++
        // }

        // foo.count = 0 //foo라는 함수 객체에 count 프로퍼티가 추가됨 
        // //하지만 this.count에서 this는 함수 객체를 바라보는 것이 아니며, 프로퍼티 명이 똑같아 헷갈리지만 근거지를 둔 객체가 다르다 
        // var i;
        // for (let i = 0; i < 10; i++) {
        //     if (i > 5) {
        //         foo(i)
        //     }
        // }
        // console.log(foo.count)

        // function foo(num) {
        //     console.log("foo" + num)

        //     data.count++
        // }

        // var data = { count: 0 }
        // var i;
        // for (let i = 0; i < 10; i++) {
        //     if (i > 5) {
        //         foo(i)
        //     }
        // }
        // console.log(data.count)


        // function foo(num) {
        //     foo.count = 4
        // }

        // setTimeout(() => {

        // }, 10);

        // var x = 'global';

        // function foo() {
        //     var x = 'function scope';
        //     console.log(x);
        // }

        // foo(); // ?
        // console.log(x); // ?

        // var x = 0;
        // {
        //     var x = 1;
        //     console.log(x); // 1
        // }
        // console.log(x);   // 1

        // let y = 0;
        // {
        //     let y = 1;
        //     console.log(y); // 1
        // }
        // console.log(y);   // 0


        // var global = 'global';

        // function foo() {
        //     var local = 'local';
        //     console.log(global);
        //     console.log(local);
        // }
        // foo();

        // console.log(global);
        // console.log(local); 

        // if (true) {
        //     var x = 5;
        // }
        // console.log(x);

        // var a = 10;     // 전역변수

        // (function () {
        //     var b = 20;   // 지역변수
        // })();

        // console.log(a); // 10
        // console.log(b); // "b" is not defined

        // var x = 'global';

        // function foo() {
        //     var x = 'local';
        //     console.log(x);
        // }

        // foo();          // local
        // console.log(x); // global
        // 전역변수 x와 지역변수 x가 중복 선언되었다. 전역 영역에서는 전역변수만이 참조 가능하고 
        //함수 내 지역 영역에서는 전역과 지역 변수 모두 참조 가능하나 위 예제와 같이 변수명이 중복된 경우, 지역변수를 우선하여 참조한다.


        // var x = 'global';

        // function foo() {
        //     var x = 'local';
        //     console.log(x);

        //     function bar() {  // 내부함수
        //         console.log(x); // ?
        //     }

        //     bar();
        // }
        // foo();
        // console.log(x); // ?
        //내부함수는 자신을 포함하고 있는 외부함수의 변수에 접근할 수 있다. 이는 매우 유용하다. 클로저에서와 같이 내부함수가 더 오래 생존하는 경우, 타 언어와는 다른 움직임을 보인다.
        // 함수 bar에서 참조하는 변수 x는 함수 foo에서 선언된 지역변수이다. 이는 실행 컨텍스트의 스코프 체인에 의해 참조 순위에서 전역변수 x가 뒤로 밀렸기 때문이다.

        // var x = 10;

        // function foo() {
        //     x = 100; //var를 붙이면 지역변수 됨 전역변수에 영향을 주지 않음
        //     console.log(x);
        // }
        // foo();
        // console.log(x); // ?
        //함수(지역) 영역에서 전역변수를 참조할 수 있으므로 전역변수의 값도 변경할 수 있다. 내부 함수의 경우, 전역변수는 물론 상위 함수에서 선언한 변수에 접근/변경이 가능하다.


        // var foo = function () {

        //     var a = 3, b = 5;

        //     var bar = function () {
        //         var b = 7, c = 11;

        //         // 이 시점에서 a는 3, b는 7, c는 11

        //         a += b + c;

        //         // 이 시점에서 a는 21, b는 7, c는 11

        //     };

        //     // 이 시점에서 a는 3, b는 5, c는 not defined

        //     bar();

        //     // 이 시점에서 a는 21, b는 5

        // };

        // var x = 1;

        // function foo() {
        //     var x = 10;
        //     bar(); //10
        // }

        // function bar() {
        //     console.log(x);
        // }

        // foo(); // ?
        // bar(); // ?
        // 위 예제의 실행 결과는 함수 bar의 상위 스코프가 무엇인지에 따라 결정된다.
        // 두가지 패턴을 예측할 수 있는데 첫번째는 함수를 어디서 호출하였는지에 따라 상위 스코프를 결정하는 것이고 
        // 두번째는 함수를 어디서 선언하였는지에 따라 상위 스코프를 결정하는 것이다.
        // 첫번째 방식으로 함수의 상위 스코프를 결정한다면 함수 bar의 상위 스코프는 함수 foo와 전역일 것이고, 두번째 방식으로 함수의 스코프를 결정한다면 함수 bar의 스코프는 전역일 것이다.

        // 첫번째 방식을 동적 스코프(Dynamic scope)라 하고, 
        // 두번째 방식을 렉시컬 스코프(Lexical scope) 또는 정적 스코프(Static scope)라 한다. 
        // 자바스크립트를 비롯한 대부분의 프로그래밍 언어는 렉시컬 스코프를 따른다.

        // 렉시컬 스코프는 함수를 어디서 호출하는지가 아니라 어디에 선언하였는지에 따라 결정된다. 
        // 자바스크립트는 렉시컬 스코프를 따르므로 함수를 선언한 시점에 상위 스코프가 결정된다. 
        // 함수를 어디에서 호출하였는지는 스코프 결정에 아무런 의미를 주지 않는다. 

        // var x = 10; // 전역 변수

        // function foo() {
        //     // 선언하지 않은 식별자
        //     y = 20;
        //     console.log(x + y);
        // }

        // foo(); // 30
        // 위 예제의 y는 선언하지 않은 식별자이다. 따라서 y = 20이 실행되면 참조 에러가 발생할 것처럼 보인다.
        // 하지만 선언하지 않은 식별자 y는 마치 선언된 변수처럼 동작한다. 이는 선언하지 않은 식별자에 값을 할당하면 전역 객체의 프로퍼티가 되기 때문이다.
        // 자바스크립트 엔진은 y = 20을 window.y = 20으로 해석하여 프로퍼티를 동적 생성한다. 
        // 결국 y는 전역 객체의 프로퍼티가 되어 마치 전역 변수처럼 동작한다. 이러한 현상을 암묵적 전역(implicit global)이라 한다.

        // // 전역 변수 x는 호이스팅이 발생한다.
        // console.log(x); // undefined
        // // 전역 변수가 아니라 단지 전역 프로퍼티인 y는 호이스팅이 발생하지 않는다.
        // console.log(y); // ReferenceError: y is not defined

        // var x = 10; // 전역 변수

        // function foo() {
        //     // 선언하지 않은 변수
        //     y = 20;
        //     console.log(x + y);
        // }

        // foo(); // 30

        // var x = 10; // 전역 변수

        // function foo() {
        //     // 선언하지 않은 변수
        //     y = 20;
        //     console.log(x + y);
        // }

        // foo(); // 30

        // console.log(window.x); // 10
        // console.log(window.y); // 20

        // delete x; // 전역 변수는 삭제되지 않는다.
        // delete y; // 프로퍼티는 삭제된다.

        // console.log(window.x); // 10
        // console.log(window.y); // undefined

        // 전역변수 사용을 최소화하는 방법 중 하나는 애플리케이션에서 전역변수 사용을 위해 다음과 같이 전역변수 객체 하나를 만들어 사용하는 것이다. (더글라스 크락포드의 제안)
        // var MYAPP = {};

        // MYAPP.student = {
        //     name: 'Lee',
        //     gender: 'male'
        // };

        // console.log(MYAPP.student.name);

        // 전역변수 사용을 억제하기 위해, 즉시 실행 함수(IIFE, Immediately-Invoked Function Expression)를 사용할 수 있다. 
        // 이 방법을 사용하면 전역변수를 만들지 않으므로 라이브러리 등에 자주 사용된다. 즉시 실행 함수는 즉시 실행되고 그 후 전역에서 바로 사라진다.
        // (function () {
        //     var MYAPP = {};

        //     MYAPP.student = {
        //         name: 'Lee',
        //         gender: 'male'
        //     };

        //     console.log(MYAPP.student.name);
        // }());

        // console.log(MYAPP.student.name);

        // function baz() {
        //     //호출 스택: baz
        //     //따라서 호출부는 전역 스코프 내부다.

        //     console.info("baz")
        //     bar()
        // }
        // function bar() {
        //     console.log("bar")
        //     foo()
        // }
        // function foo() {
        //     console.info("foo")
        // }

        // baz();

        // function foo(somthing) {
        //     console.log(this.a, somthing);
        //     return this.a + somthing
        // }

        // var obj = {
        //     a: 2
        //     // foo: foo
        // }
        // // var bar = function () {

        // //     return foo.apply(obj, arguments)
        // // }

        // var bar = foo.bind(obj)
        // var b = bar(3)
        // console.info(b)
        // bar();//2

        // setTimeout(bar, 100); //2

        // bar.call(window);//2
        // function doFoo(fn) {
        //     fn()
        // }

        // var obj1 = {
        //     a: 2,
        //     obj2: obj2
        // }
        // obj1.obj2.foo()//42
        // var bar = obj.foo;
        // var a = "엥 전역이네"
        // doFoo(obj.foo)
        // setTimeout((fn, delay) => {
        //     fn()
        // }, timeout);

        // function foo(a) {
        //     this.a = a;
        // }
        // var bar = new foo(3);//foo 는 this로 바인딩 됨

        // console.log(bar.a) //foo.a 를 호출 한 것과 똑같음

        // function foo(p1, p2) {
        //     this.val = p1 + p2;
        // }
        // var bar = foo.bind(null, "p1")
        // // console.info(bar.val)
        // var baz = new bar("p2")
        // // console.info(bar.val)
        // console.info(baz.val)

        // var myArray = ["foo", 42, "bar"]
        // myArray[3] = "baz"
        // myArray["3"] = "baz3"
        // console.info(
        //     myArray["3"]
        // )
        // console.info(myArray.length)

        // const o1 = { a: 1 };
        // const o2 = { b: 2 };
        // const o3 = { c: 3 };

        // const obj = Object.assign(o1, o2, o3);
        // console.log(obj); // { a: 1, b: 2, c: 3 }
        // console.log(o1);  // { a: 1, b: 2, c: 3 }, 대상 객체 자체가 변경됨.        
        // function Person() {
        //     this.eyes = 2;
        //     this.nose = 1;
        // }
        // var kim = new Person();
        // var park = new Person();
        // console.log(kim.eyes);  // => 2
        // console.log(kim.nose);  // => 1
        // console.log(park.eyes); // => 2
        // console.log(park.nose); // => 1

        function Person() { }
        Person.prototype.eyes = 2;
        Person.prototype.nose = 1;
        var kim = new Person();
        var park = new Person();
        console.log(kim.eyes); // => 2

    </script>


</body>

</html>